---
name: tokensaver
description: 运行时上下文优化 - 结构化摘要、工具输出修剪、基于重要性的保留
license: MIT
compatibility: opencode
---

# TokenSaver

**优化上下文以减少Token成本。**

⚠️ **此技能不会自动减少Token。** 你必须主动应用这些策略。

---

## 🚨 何时激活此技能

| 触发条件 | 行动 |
|----------|------|
| 上下文 > 50%模型限制 | 开始监控 |
| 上下文 > 70%模型限制 | 主动压缩 |
| 子任务完成后 | 摘要和修剪 |
| 昂贵操作前 | 清理上下文 |
| 长时间运行会话 | 定期清理 |

---

## 核心原则：每任务Token数

```
❌ 错误：最小化每次请求的Token
✅ 正确：最小化完成任务的Token总数

激进压缩丢失信息 → 重新获取 → 浪费更多Token
```

**优化目标：** 足够压缩以省钱，足够保留以避免返工。

---

## 策略1：结构化摘要

用此格式替换旧消息：

```markdown
## 会话摘要

### 用户意图
[1-2句话 - 用户想完成什么]

### 修改的文件
- `路径/文件.ts`: [改了什么，1行]
- `路径/其他.ts`: [改了什么，1行]

### 关键决策
- [决策1]: [理由]
- [决策2]: [理由]

### 当前状态
[什么能工作，什么阻塞，下一步]

### 必须保留
- 文件路径: [...]
- 函数名: [...]
- 错误信息: [...]
- 关键上下文: [...]
```

**何时摘要：**
- 会话中20+次工具调用
- 重复读取文件
- 任务阶段完成

---

## 策略2：工具输出修剪

### 移除重复读取

```
❌ 保留：同一文件的5次读取结果
✅ 保留：只保留最新的读取，修剪更早的

规则：如果读取文件X 3次，只保留最后一次读取。
```

### 写入后压缩

```
❌ 保留：写入内容 + 后来读取内容
✅ 修剪：写入内容，只保留读取结果

规则：写入后后来又读取同一文件，写入就是冗余的。
```

### 清理旧错误

4+轮后，修剪失败输入（保留错误消息）：

```
❌ 保留：500行失败输入 + 错误消息
✅ 保留："[输入已修剪 - 500行] 错误：无法读取属性'x'"
```

---

## 策略3：避免重复探索

**不要对同一模式探索两次。**

```
❌ 错误流程：
   grep "auth" → 结果 → 后来又grep "auth" → 相同结果

✅ 正确流程：
   grep "auth" → 记住："认证模式在 src/middleware/auth.ts"
   后来：使用记忆，不重新探索
```

### 记忆检查点

每次发现后，心理检查：

```
✓ 认证：src/middleware/auth.ts
✓ 数据库：src/models/
✓ 测试：Vitest框架
✓ API：Express路由在 src/routes/
```

上下文增长时，合并为一个摘要。

---

## 策略4：基于优先级的保留

| 优先级 | 内容类型 | 行动 |
|--------|----------|------|
| **P1** | 文件路径、函数名、错误消息 | 永不修剪 |
| **P1** | 用户核心意图 | 永不修剪 |
| **P2** | 做出的决策 + 理由 | 摘要 |
| **P2** | 修改的文件 + 变更 | 摘要 |
| **P3** | 探索过程日志 | 大量压缩 |
| **P3** | 失败尝试 | 只保留教训 |
| **P4** | 重复工具输出 | 完全修剪 |

---

## 实际应用

### 每次主要操作前问：

- [ ] 上下文 > 70%限制？ → 考虑压缩
- [ ] 读同一文件3+次？ → 修剪更早的读取
- [ ] 任务阶段完成？ → 摘要和修剪
- [ ] 10+错误输出？ → 清理旧的
- [ ] 冗长输出？ → 用摘要替换

---

## Token估算

| 内容 | 比例 |
|------|------|
| 英文文本 | ~4字符/token |
| 代码 | ~3字符/token |
| 中文/日文 | ~1.5字符/token |

### 模型限制

| 模型 | 上下文窗口 | 安全阈值 |
|------|------------|----------|
| GPT-4o | 128K | 100K tokens |
| Claude 3.5 | 200K | 150K tokens |
| GPT-4-turbo | 128K | 100K tokens |
| GPT-3.5-turbo | 16K | 12K tokens |

---

## 前后示例

### 之前（50,000 tokens）
```
[20条文件探索消息]
[15个读取工具结果，有些重复]
[8次失败尝试及完整错误日志]
[5次写入操作及完整内容]
[10条"让我检查X，然后Y"消息]
```

### 之后（8,000 tokens）
```markdown
## 会话摘要

### 用户意图
为REST API实现JWT认证

### 修改的文件
- `src/middleware/auth.ts`: 添加JWT验证
- `src/routes/auth.ts`: 登录/登出端点
- `tests/auth.test.ts`: 12个认证测试

### 关键决策
- httpOnly cookies（XSS防护）
- Token过期：15分钟访问，7天刷新
- 速率限制：每IP 100请求/分钟

### 当前状态
- 12/15测试通过
- 剩余：3个token刷新边界情况

### 必须保留
- JWT密钥：process.env.JWT_SECRET
- 算法：HS256
- 错误行47：需要空值检查
```

---

## 反模式

| ❌ 不要 | 结果 |
|----------|--------|
| 保留所有内容 | 膨胀，高成本，慢 |
| 激进压缩 | 丢失信息，重新获取，成本更高 |
| 忽略此技能 | 阅读 = 浪费tokens |
| 非结构化摘要 | 关键细节丢失 |

---

## 与插件集成

对于**自动**上下文优化，结合使用：
[opencode-dynamic-context-pruning](https://github.com/Opencode-DCP/opencode-dynamic-context-pruning)

此技能 = 手动策略
插件 = 自动修剪

**最佳效果：** 两者结合使用。

---

## 快速参考

```
1. 摘要旧上下文 → 结构化格式
2. 修剪重复和错误
3. 保留P1内容（路径、错误、意图）
4. 昂贵操作前检查
5. 主动应用 - 阅读 ≠ 应用

关键指标：每任务Token数，不是每请求Token数
```
