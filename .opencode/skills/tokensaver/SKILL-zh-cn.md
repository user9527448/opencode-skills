---
name: tokensaver
description: 运行时上下文优化策略，减少OpenCode会话中的Token消耗
license: MIT
compatibility: opencode
---

# TokenSaver

优化上下文以减少Token成本。主动策略，不是被动建议。

## ⚠️ 关键警告

**此技能不会自动减少Token。** 你必须主动应用这些策略。

```
阅读此技能 = +1500 tokens
应用此技能 = -50000 tokens（净节省）
忽略此技能 = 浪费tokens
```

---

## 核心原则：每任务Token数

**错误：** 最小化每次请求的Token
**正确：** 最小化完成任务的Token总数

激进的压缩会丢失信息 → 导致重新获取 → 浪费更多Token。

---

## 何时激活

| 触发条件 | 行动 |
|----------|------|
| 上下文 > 50%限制 | 开始监控 |
| 上下文 > 70%限制 | 主动压缩 |
| 子任务完成后 | 摘要和修剪 |
| 昂贵操作前 | 清理上下文 |

---

## 策略1: 结构化摘要

用此摘要格式替换旧消息：

```markdown
## 会话摘要

### 用户意图
[1-2句话]

### 修改的文件
- `路径/文件.ts`: [改了什么]

### 关键决策
- [决策 + 理由]

### 当前状态
[状态和下一步]

### 必须保留
[文件路径、错误消息、关键上下文]
```

**何时：** 20+次工具调用、重复读取、或阶段完成

---

## 策略2: 工具输出修剪

### 移除重复读取
```
❌ 保留同一文件的5次读取结果
✅ 只保留最新的读取
```

### 写入后压缩
```
❌ 保留写入 + 后来的读取
✅ 修剪写入，保留读取结果
```

### 清理旧错误
4+轮后，保留错误消息但修剪失败的输入：
```
❌ 500行失败输入 + 错误
✅ "[已修剪] - 错误：无法读取属性'x'"
```

---

## 策略3: 避免重复探索

不要对同一模式grep两次。记住发现：

```
❌ grep "auth" → 结果 → 后来又grep "auth"
✅ 记住："认证模式在 src/middleware/auth.ts"
```

---

## 策略4: 基于优先级的保留

| 优先级 | 保留 | 修剪 |
|--------|------|------|
| P1 | 文件路径、错误、用户意图 | 永不 |
| P2 | 决策、文件变更 | 摘要 |
| P3 | 探索日志 | 压缩 |
| P4 | 重复读取 | 完全修剪 |

---

## 快速检查清单

主要操作前：

- [ ] 上下文 > 70%？ → 压缩
- [ ] 读同一文件3次？ → 修剪旧的
- [ ] 阶段完成？ → 摘要
- [ ] 10+个错误？ → 清理旧的

---

## Token估算

| 内容 | 比例 |
|------|------|
| 英文 | ~4字符/token |
| 代码 | ~3字符/token |
| 中文 | ~1.5字符/token |

---

## 反模式

| ❌ 不要 | 结果 |
|----------|------|
| 保留所有内容 | 膨胀，高成本 |
| 激进压缩 | 丢失信息，重新获取 |
| 忽略此技能 | 浪费tokens |

---

## 集成

结合 [opencode-dynamic-context-pruning](https://github.com/Opencode-DCP/opencode-dynamic-context-pruning) 实现自动 + 手动优化。

---

## 快速参考

```
1. 摘要旧上下文 → 结构化格式
2. 修剪重复和错误
3. 保留文件路径和决策
4. 昂贵操作前检查
```
