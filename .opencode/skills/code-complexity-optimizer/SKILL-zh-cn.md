---
name: code-complexity-optimizer
description: 算法复杂度优化技能。分析时间/空间复杂度，通过交互式问答引导优化，并提供权衡分析。触发词："代码优化"或"复杂度优化"。
license: MIT
compatibility: opencode
metadata:
  author: user9527448
  tags:
    - optimization
    - complexity
    - performance
    - algorithms
  triggers:
    - "代码优化"
    - "code optimization"
    - "complexity optimization"
    - "时间复杂度优化"
    - "空间复杂度优化"
    - "性能优化"
    - "algorithm optimization"
---

# 代码复杂度优化器

## 概述

通过复杂度分析进行系统性算法优化。分析时间复杂度（O(n)、O(log n)、O(n²)等）和空间复杂度，通过交互式问答引导优化，并提供清晰的权衡建议。

## 触发条件

**当用户请求以下内容时使用此技能：**
- "代码优化" / "code optimization"
- "复杂度优化" / "complexity optimization"
- "时间复杂度优化" / "time complexity optimization"
- "空间复杂度优化" / "space complexity optimization"
- "性能优化" / "performance optimization"
- "算法优化" / "algorithm optimization"
- 或提及 O(n)、大O表示法、性能瓶颈

---

## 阶段 1: 代码分析

### 步骤 1.1: 识别目标代码

如果用户未指定要优化的代码：
```
请提供需要优化的代码片段或指出具体文件/函数位置。
```

### 步骤 1.2: 分析当前复杂度

**必须：在任何优化之前，分析并记录：**

| 方面 | 当前值 | 证据 |
|------|--------|------|
| 时间复杂度 | O(?) | 识别循环、递归、嵌套操作 |
| 空间复杂度 | O(?) | 识别数据结构、递归深度、内存分配 |
| 输入规模范围 | n = ? | 代码处理的典型输入大小 |
| 性能瓶颈 | ? | 什么操作主导运行时间 |

**分析清单：**
- [ ] 计算循环迭代次数（嵌套循环 → O(n²)、O(n³)）
- [ ] 识别递归深度和分支
- [ ] 检查数据结构操作（哈希表查找 vs 数组搜索）
- [ ] 注意字符串操作（循环中的拼接）
- [ ] 识别冗余计算

**常见复杂度模式：**

| 模式 | 时间 | 空间 | 示例 |
|------|------|------|------|
| 单层循环 | O(n) | O(1) | 线性搜索 |
| 嵌套循环 | O(n²) | O(1) | 冒泡排序 |
| 二分递归 | O(2ⁿ) | O(n) | 朴素斐波那契 |
| 分治算法 | O(n log n) | O(log n) | 归并排序 |
| 哈希表查找 | O(1) 平均 | O(n) | 字典访问 |
| 排序 | O(n log n) | O(n) | 内置排序 |

---

## 阶段 2: 明确优化目标

### 步骤 2.1: 询问澄清问题

**如果用户未指定优化方向，询问：**

```
我分析了代码的当前复杂度：
- 时间复杂度: O(?)
- 空间复杂度: O(?)

请告诉我您的优化目标：
1. 【优先时间】希望减少运行时间（牺牲空间换时间）
2. 【优先空间】希望减少内存占用（牺牲时间换空间）
3. 【平衡优化】在时间和空间之间寻找平衡
4. 【自动判断】让我根据实际情况选择最优方案
```

### 步骤 2.2: 了解约束条件

询问以下内容：
- **输入规模**: n 通常有多大？（10、1000、10⁶？）
- **调用频率**: 此代码多久被调用一次？
- **运行环境**: 内存限制？时间限制？
- **正确性要求**: 算法可以改变吗？必须保持完全相同的行为？

---

## 阶段 3: 优化策略选择

### 时间优化策略

| 策略 | 使用场景 | 权衡 |
|------|----------|------|
| 哈希表 / 集合 | 频繁查找 | +空间 |
| 记忆化 | 重复子问题 | +空间 |
| 预计算 | 已知输入模式 | +空间 |
| 惰性求值 | 不需要所有结果 | 复杂度 |
| 双指针 | 有序/链表结构 | - |
| 滑动窗口 | 连续子数组 | - |
| 二分查找 | 有序数据 | - |
| 提前退出 | 带条件的搜索 | - |

### 空间优化策略

| 策略 | 使用场景 | 权衡 |
|------|----------|------|
| 原地算法 | 数组修改 | +时间 |
| 生成器/迭代器 | 大型序列 | +时间 |
| 引用传递 | 大对象 | 可变状态 |
| 位操作 | 布尔标志 | 复杂度 |
| 流式处理 | 大数据集 | +时间 |
| 递归转迭代 | 深度递归 | 栈空间 |

### 平衡优化

| 策略 | 时间影响 | 空间影响 |
|------|----------|----------|
| 最优数据结构 | ↓ | ↓ |
| 算法替换 | ↓ | ↔ |
| 代码简化 | ↓ | ↓ |

---

## 阶段 4: 优化执行

### 步骤 4.1: 提出变更建议

**格式：**
```
优化方案: [策略名称]

当前复杂度: 时间 O(?), 空间 O(?)
优化后复杂度: 时间 O(?), 空间 O(?)

改进点:
- [具体改进1]
- [具体改进2]

权衡说明:
- [时间/空间变化]
- [适用场景]

是否应用此优化？
```

### 步骤 4.2: 应用变更

当用户确认后：
1. **最小化变更** - 不重构无关代码
2. **保持行为** - 输出必须完全相同
3. **添加注释** - 解释优化原理
4. **保留原始代码** - 用户可能想要对比

### 步骤 4.3: 验证正确性

**优化后必须：**
- [ ] 运行现有测试
- [ ] 测试边界情况
- [ ] 对比优化前后输出
- [ ] 检查新引入的 bug

---

## 阶段 5: 复杂度验证

### 提供最终报告

```
优化完成报告

代码: [函数/文件名]

优化前:
- 时间复杂度: O(?)
- 空间复杂度: O(?)

优化后:
- 时间复杂度: O(?)
- 空间复杂度: O(?)
- 实际提升: [预期改进]

使用策略:
- [策略1]
- [策略2]

注意事项:
- [任何权衡或限制]
```

---

## 自主优化的决策树

当用户选择"自动判断"时，遵循以下逻辑：

```
IF 输入规模 < 100:
    → 优先可读性，最小化优化
ELIF 输入规模 < 10000:
    → 标准优化（哈希表、提前退出）
ELIF 输入规模 < 1000000:
    → 激进的时间优化
ELSE:
    → 考虑流式处理、分块、外部算法

IF 内存受限:
    → 优先原地操作、迭代器、流式处理
IF 时间关键:
    → 优先预计算、缓存、哈希结构
```

---

## 常见优化模式

### 1. O(n²) → O(n) 通过哈希表

```python
# 优化前: O(n²)
for i in range(n):
    for j in range(n):
        if arr[i] + arr[j] == target:
            return (i, j)

# 优化后: O(n)
seen = {}
for i, num in enumerate(arr):
    if target - num in seen:
        return (seen[target - num], i)
    seen[num] = i
```

### 2. O(n) → O(log n) 通过二分查找

```python
# 优化前: O(n)
for i, val in enumerate(sorted_arr):
    if val == target:
        return i

# 优化后: O(log n)
left, right = 0, len(sorted_arr) - 1
while left <= right:
    mid = (left + right) // 2
    if sorted_arr[mid] == target:
        return mid
    elif sorted_arr[mid] < target:
        left = mid + 1
    else:
        right = mid - 1
```

### 3. O(2ⁿ) → O(n) 通过记忆化

```python
# 优化前: O(2ⁿ)
def fib(n):
    if n <= 1:
        return n
    return fib(n-1) + fib(n-2)

# 优化后: O(n)
def fib(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fib(n-1, memo) + fib(n-2, memo)
    return memo[n]
```

### 4. 空间 O(n) → O(1) 原地操作

```python
# 优化前: O(n) 空间
result = arr[::-1]

# 优化后: O(1) 空间
left, right = 0, len(arr) - 1
while left < right:
    arr[left], arr[right] = arr[right], arr[left]
    left += 1
    right -= 1
```

---

## 需要避免的反模式

| 反模式 | 为何不好 | 修复方法 |
|--------|----------|----------|
| 过早优化 | 浪费时间，损害可读性 | 先分析性能 |
| 循环中字符串拼接 | O(n²) 由于复制 | 使用 join/buffer |
| 复制大型数组 | 浪费内存 | 使用引用/视图 |
| 深度递归 | 栈溢出 | 转换为迭代 |
| 全局状态缓存 | 线程安全问题 | 使用局部缓存 |
| 过度工程化 | 维护负担 | 保持简单 |

---

## 快速参考卡

```
┌─────────────────────────────────────────────┐
│          复杂度优化速查表                    │
├─────────────────────────────────────────────┤
│ 时间 ↓                                      │
│   嵌套循环        → 哈希表 / 集合           │
│   重复计算        → 记忆化                  │
│   线性搜索        → 二分查找（有序）        │
│   全量扫描        → 提前退出                │
├─────────────────────────────────────────────┤
│ 空间 ↓                                      │
│   新建数组        → 原地修改                │
│   完整列表        → 生成器/迭代器           │
│   深度递归        → 迭代式                  │
│   对象复制        → 引用传递                │
├─────────────────────────────────────────────┤
│ 平衡                                        │
│   错误数据结构    → 正确数据结构            │
│   朴素算法        → 最优算法                │
└─────────────────────────────────────────────┘
```

---

## 示例工作流

**用户**: "优化这段代码的代码优化"

```python
def find_duplicates(arr):
    duplicates = []
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            if arr[i] == arr[j] and arr[i] not in duplicates:
                duplicates.append(arr[i])
    return duplicates
```

**智能体响应**:
```
分析结果:
- 时间复杂度: O(n³) - 双重循环 O(n²) × not in 检查 O(n)
- 空间复杂度: O(n) - duplicates 数组
- 瓶颈: 嵌套循环 + 线性查找

优化方案建议:

1. 【优先时间】使用集合去重
   - 时间: O(n²) → O(n)
   - 空间: O(n)（增加一个集合）
   
2. 【平衡优化】使用 Counter
   - 时间: O(n)
   - 空间: O(n)
   
请选择优化方向，或让我自动判断？
```

---

## 集成说明

- 与 `test-driven-debugging` 技能配合验证优化结果
- 与 `safe-refactoring` 技能配合进行复杂重构
- 优化后使用 `code-review-guardian` 技能进行质量检查

---

## 限制

- 无法优化外部库代码
- 需要测试覆盖率以确保安全
- 某些优化是语言特定的
- 可能不适用于所有编程范式
