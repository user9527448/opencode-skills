---
name: code-complexity-optimizer
description: 算法复杂度优化技能。分析时间/空间复杂度，通过交互式问答引导优化，并提供权衡分析。
license: MIT
compatibility: opencode
metadata:
  author: user9527448
  tags:
    - optimization
    - complexity
    - performance
    - algorithms
  triggers:
    - "代码优化"
    - "code optimization"
    - "complexity optimization"
    - "时间复杂度优化"
    - "空间复杂度优化"
    - "性能优化"
    - "algorithm optimization"
  references:
    languages: references/languages/
    paradigms: references/paradigms/
    examples: examples/
    templates: templates/
    scripts: scripts/
---

# 代码复杂度优化器

## 概述

通过复杂度分析进行系统性算法优化。分析时间复杂度（O(n)、O(log n)、O(n²)等）和空间复杂度，通过交互式问答引导优化，并提供清晰的权衡建议。

## 触发条件

**当用户请求以下内容时使用此技能：**
- "代码优化" / "code optimization"
- "复杂度优化" / "complexity optimization"
- "时间复杂度优化" / "time complexity optimization"
- "空间复杂度优化" / "space complexity optimization"
- "性能优化" / "performance optimization"
- "算法优化" / "algorithm optimization"
- 或提及 O(n)、大O表示法、性能瓶颈

---

## 核心原则

> **优化前必须分析复杂度。** 永远不要猜测——先测量并记录当前状态。

---

## 阶段 1: 代码分析

### 步骤 1.1: 识别目标代码

如果用户未指定要优化的代码：
```
请提供需要优化的代码片段或指出具体文件/函数位置。
```

### 步骤 1.2: 分析当前复杂度

**必须：在任何优化之前，分析并记录：**

| 方面 | 当前值 | 证据 |
|------|--------|------|
| 时间复杂度 | O(?) | 识别循环、递归、嵌套操作 |
| 空间复杂度 | O(?) | 识别数据结构、递归深度、内存分配 |
| 输入规模范围 | n = ? | 代码处理的典型输入大小 |
| 性能瓶颈 | ? | 什么操作主导运行时间 |

**分析清单：**
- [ ] 计算循环迭代次数（嵌套循环 → O(n²)、O(n³)）
- [ ] 识别递归深度和分支
- [ ] 检查数据结构操作（哈希表查找 vs 数组搜索）
- [ ] 注意字符串操作（循环中的拼接）
- [ ] 识别冗余计算

**常见复杂度模式：**

| 模式 | 时间 | 空间 | 示例 |
|------|------|------|------|
| 单层循环 | O(n) | O(1) | 线性搜索 |
| 嵌套循环 | O(n²) | O(1) | 冒泡排序 |
| 二分递归 | O(2ⁿ) | O(n) | 朴素斐波那契 |
| 分治算法 | O(n log n) | O(log n) | 归并排序 |
| 哈希表查找 | O(1) 平均 | O(n) | 字典访问 |
| 排序 | O(n log n) | O(n) | 内置排序 |

---

## 阶段 2: 明确优化目标

### 步骤 2.1: 询问澄清问题

**如果用户未指定优化方向，询问：**

```
我分析了代码的当前复杂度：
- 时间复杂度: O(?)
- 空间复杂度: O(?)

请告诉我您的优化目标：
1. 【优先时间】希望减少运行时间（牺牲空间换时间）
2. 【优先空间】希望减少内存占用（牺牲时间换空间）
3. 【平衡优化】在时间和空间之间寻找平衡
4. 【自动判断】让我根据实际情况选择最优方案
```

### 步骤 2.2: 了解约束条件

询问以下内容：
- **输入规模**: n 通常有多大？（10, 1000, 10⁶？）
- **调用频率**: 此代码多久被调用一次？
- **运行环境**: 内存限制？时间限制？
- **正确性要求**: 算法可以改变吗？必须保持完全相同的行为？

---

## 阶段 3: 优化策略选择

### 时间优化策略

| 策略 | 使用场景 | 权衡 |
|------|----------|------|
| 哈希表 / 集合 | 频繁查找 | +空间 |
| 记忆化 | 重复子问题 | +空间 |
| 预计算 | 已知输入模式 | +空间 |
| 惰性求值 | 不需要所有结果 | 复杂度 |
| 双指针 | 有序/链表结构 | - |
| 滑动窗口 | 连续子数组 | - |
| 二分查找 | 有序数据 | - |
| 提前退出 | 带条件的搜索 | - |

### 空间优化策略

| 策略 | 使用场景 | 权衡 |
|------|----------|------|
| 原地算法 | 数组修改 | +时间 |
| 生成器/迭代器 | 大型序列 | +时间 |
| 引用传递 | 大对象 | 可变状态 |
| 位操作 | 布尔标志 | 复杂度 |
| 流式处理 | 大数据集 | +时间 |
| 递归转迭代 | 深度递归 | 栈空间 |

### 平衡优化

| 策略 | 时间影响 | 空间影响 |
|------|----------|----------|
| 最优数据结构 | ↓ | ↓ |
| 算法替换 | ↓ | ↔ |
| 代码简化 | ↓ | ↓ |

---

## 阶段 4: 优化执行

### 步骤 4.1: 提出变更建议

**格式：**
```
优化方案: [策略名称]

当前复杂度: 时间 O(?), 空间 O(?)
优化后复杂度: 时间 O(?), 空间 O(?)

改进点:
- [具体改进1]
- [具体改进2]

权衡说明:
- [时间/空间变化]
- [适用场景]

是否应用此优化？
```

### 步骤 4.2: 应用变更

当用户确认后：
1. **最小化变更** - 不重构无关代码
2. **保持行为** - 输出必须完全相同
3. **添加注释** - 解释优化原理
4. **保留原始代码** - 用户可能想要对比

### 步骤 4.3: 验证正确性

**优化后必须：**
- [ ] 运行现有测试
- [ ] 测试边界情况
- [ ] 对比优化前后输出
- [ ] 检查新引入的 bug

---

## 阶段 5: 复杂度验证

### 提供最终报告

```
优化完成报告

代码: [函数/文件名]

优化前:
- 时间复杂度: O(?)
- 空间复杂度: O(?)

优化后:
- 时间复杂度: O(?)
- 空间复杂度: O(?)
- 实际提升: [预期改进]

使用策略:
- [策略1]
- [策略2]

注意事项:
- [任何权衡或限制]
```

---

## 自主优化的决策树

当用户选择"自动判断"时，遵循以下逻辑：

```
IF 输入规模 < 100:
    → 优先可读性，最小化优化
ELIF 输入规模 < 10000:
    → 标准优化（哈希表、提前退出）
ELIF 输入规模 < 1000000:
    → 激进的时间优化
ELSE:
    → 考虑流式处理、分块、外部算法

IF 内存受限:
    → 优先原地操作、迭代器、流式处理
IF 时间关键:
    → 优先预计算、缓存、哈希结构
```

---

## 需要避免的反模式

| 反模式 | 为何不好 | 修复方法 |
|--------|----------|----------|
| 过早优化 | 浪费时间，损害可读性 | 先分析性能 |
| 循环中字符串拼接 | O(n²) 由于复制 | 使用 join/buffer |
| 复制大型数组 | 浪费内存 | 使用引用/视图 |
| 深度递归 | 栈溢出 | 转换为迭代 |
| 全局状态缓存 | 线程安全问题 | 使用局部缓存 |
| 过度工程化 | 维护负担 | 保持简单 |

---

## 快速参考卡

```
┌─────────────────────────────────────────────┐
│          复杂度优化速查表                    │
├─────────────────────────────────────────────┤
│ 时间 ↓                                      │
│   嵌套循环        → 哈希表 / 集合           │
│   重复计算        → 记忆化                  │
│   线性搜索        → 二分查找（有序）        │
│   全量扫描        → 提前退出                │
├─────────────────────────────────────────────┤
│ 空间 ↓                                      │
│   新建数组        → 原地修改                │
│   完整列表        → 生成器/迭代器           │
│   深度递归        → 迭代式                  │
│   对象复制        → 引用传递                │
├─────────────────────────────────────────────┤
│ 平衡                                        │
│   错误数据结构    → 正确数据结构            │
│   朴素算法        → 最优算法                │
└─────────────────────────────────────────────┘
```

---

## 工具集成

### 自动化复杂度分析

使用 `scripts/analyze.py` 进行多语言复杂度分析：

```bash
pip install lizard radon
python scripts/analyze.py src/utils.py
python scripts/analyze.py ./src --format json --output report.json
```

### 无测试基准验证

使用 `scripts/benchmark.py` 验证优化：

```bash
python scripts/benchmark.py my_module.py process_data --runs 100
python scripts/benchmark.py original.py func --compare optimized.py
```

### 验证模板

使用 `templates/verification.py` 进行快速正确性检查：

```python
from templates.verification import verify_optimization
verify_optimization(original_func, optimized_func, test_cases)
```

---

## 参考文件

详细的语言特定或范式特定指南：

| 类别 | 位置 | 内容 |
|------|------|------|
| **语言指南** | `references/languages/` | Python, JavaScript, Java, C/C++, Go 指南 |
| **范式指南** | `references/paradigms/` | OOP, FP, 响应式, 并发模式 |
| **示例** | `examples/` | 优化模式的前后对比 |
| **模板** | `templates/` | 验证和基准测试模板 |
| **脚本** | `scripts/` | analyze.py, benchmark.py |

---

## 集成说明

- 与 `test-driven-debugging` 技能配合验证优化结果
- 与 `safe-refactoring` 技能配合进行复杂重构
- 优化后使用 `code-review-guardian` 技能进行质量检查

---

## 警示信号 - 立即停止

| 想法 | 现实 | 行动 |
|------|------|------|
| "让我试试这个修复" | 猜测 | 停止 → 先执行阶段1分析 |
| "也许增加超时时间" | 掩盖症状 | 找到根本原因 |
| "这看起来很慢" | 假设 | 优化前先测量 |
| "复制粘贴这个模式" | 上下文不匹配 | 分析你的具体情况 |

---

## 限制

- 无法修改编译代码或二进制文件
- 某些优化需要运行时性能分析数据
- 硬件特定优化需要在目标平台测试
- 分布式系统优化需要基础设施变更
