---
name: test-driven-debugging
description: 四阶段系统化调试方法 - 根因调查、模式分析、假设测试、最小修复
license: MIT
compatibility: opencode
---

# 测试驱动调试

**核心原则：无根因调查，不修复。**

绝不能只针对症状打补丁。必须先理解失败原因，再尝试修复。

---

## 🚨 何时激活此技能

| 触发条件 | 优先级 |
|----------|--------|
| 任何测试失败 | 高 |
| CI/CD流水线变红 | 高 |
| "在我机器上能跑"问题 | 中 |
| 检测到不稳定测试 | 中 |
| 修改后出现回归 | 高 |

---

## 铁律

```
无根因调查，不修复

如果还没完成阶段1，就不能提出修复方案。
违反这条就是违反调试精神。
```

---

## 阶段1：根因调查

**在触碰任何代码之前：**

### 步骤1.1：仔细阅读错误信息

错误信息中的每个字都很重要。不要跳过。

```markdown
## 错误分析模板

### 完整错误信息
[复制完整的错误信息，不是摘要]

### 堆栈跟踪分析
- 栈顶：[错误表现的位置]
- 栈底：[错误源头]
- 关键帧：[重要的中间调用]

### 错误类型分类
[ ] TypeError - 类型错误/null/undefined
[ ] ReferenceError - 变量未找到
[ ] SyntaxError - 代码无法解析
[ ] AssertionError - 测试期望失败
[ ] TimeoutError - 操作超时
```

### 步骤1.2：稳定复现

```bash
# 运行特定失败测试
npm test -- --grep "精确测试名称"

# 详细输出运行
npm test -- --verbose --grep "测试名称"

# 隔离运行
npm test -- --runInBand --grep "测试名称"
```

**复现检查清单：**
- [ ] 能可靠触发吗？
- [ ] 确切步骤是什么？
- [ ] 本地和CI都失败吗？
- [ ] 单独运行失败还是只在完整套件中？

### 步骤1.3：检查最近变更

```bash
# 最近改了什么？
git log --oneline -20

# 失败文件有什么变更？
git log -p -- path/to/failing.test.ts

# Git二分查找破坏提交
git bisect start
git bisect bad HEAD
git bisect good <最后已知的好提交>
```

### 步骤1.4：收集诊断证据

| 证据类型 | 如何收集 |
|----------|----------|
| 截图 | CI产物，本地捕获 |
| 控制台日志 | `console.log`或调试器 |
| 网络请求 | DevTools Network标签 |
| 数据库状态 | 测试前后查询 |

---

## 阶段2：模式分析

### 步骤2.1：定位可工作示例

| 方面 | 可工作代码 | 失败代码 | 差异 |
|------|------------|----------|------|
| 输入 | [值] | [值] | [差异] |
| 状态 | [值] | [值] | [差异] |
| 时序 | [值] | [值] | [差异] |

### 步骤2.2：测试失败模式库

| 模式 | 可能原因 | 快速检查 |
|------|----------|----------|
| `期望X但得到Y` | 差一错误，错误返回 | 打印实际值 |
| `无法读取undefined的属性x` | 缺少空值检查，异步时序 | 追溯undefined来源 |
| `超时` | 异步未完成，无限循环 | 记录每个异步步骤 |
| `Mock未被调用` | 错误模块，不同参数 | 记录实际mock调用 |
| `元素未找到` | UI变了，选择器过时 | 检查截图 |
| `本地能跑CI失败` | 环境差异 | 比较环境 |

---

## 阶段3：假设测试

### 假设模板

```markdown
### 假设 #1
**陈述：** "错误发生因为[具体原因]"
**测试：** [如何验证 - 最小测试]
**如果为真期望：** [会看到什么]
**结果：** [确认/否定]
**新信息：** [学到了什么]
```

### 假设测试规则

1. 一次只测试一个假设
2. 做最小改动来测试
3. 记录结果后再继续
4. 如果假设失败，更新理解

### 调试日志

| # | 假设 | 测试方法 | 结果 | 结论 |
|---|------|----------|------|------|
| 1 | [猜测] | [如何] | ✓/✗ | [学到] |
| 2 | [猜测] | [如何] | ✓/✗ | [学到] |

---

## 阶段4：实现

### 步骤4.1：创建失败测试用例

```javascript
// 修复前，捕获bug行为
it('应该正确处理null输入', () => {
  const result = processInput(null);
  expect(result).toBeDefined(); // 当前会抛出
});
```

### 步骤4.2：实现最小修复

- 只改必要的部分
- 保留所有现有行为
- 修复时不重构

### 步骤4.3：验证

```bash
npm test -- --grep "修复的测试"  # 特定
npm test -- path/to/module/      # 相关
npm test                          # 完整套件
```

---

## 🛑 红旗 - 立即停止

| 想法 | 现实 | 行动 |
|------|------|------|
| "让我试试这个修复" | 瞎猜 | 停止 → 做阶段1 |
| "也许增加超时就行" | 掩盖症状 | 找根因 |
| "可能只是不稳定" | 假设 | 调查为什么不稳定 |
| "我先修再测试" | 危险 | 每次改动后都测试 |

---

## 三次失败规则

```
如果连续三次修复失败：

停止。这表明：
- 假设错误
- 架构问题
- 缺少信息

行动：
1. 回滚所有改动
2. 收集更多证据
3. 咨询其他工程师
```

---

## 快速参考

```
阶段1：根因
□ 阅读完整错误信息
□ 稳定复现
□ 检查最近变更
□ 收集证据

阶段2：模式
□ 找可工作示例
□ 对比失败代码
□ 匹配模式库

阶段3：假设
□ 形成一个假设
□ 最小化测试
□ 记录结果

阶段4：实现
□ 创建失败测试
□ 最小修复
□ 验证所有测试
```
