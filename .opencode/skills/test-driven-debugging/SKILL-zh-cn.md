---
name: test-driven-debugging
description: 四阶段系统化调试方法 - 根因调查、模式分析、假设测试、最小修复。增强版：因果调试、确定性回放和验证门禁
license: MIT
compatibility: opencode
metadata:
  references:
    patterns: references/patterns/
    scenarios: examples/scenarios/
    templates: templates/
    scripts: scripts/
  triggers:
    - "test failed"
    - "debug this"
    - "fix bug"
    - "regression"
    - "flaky test"
    - "CI red"
---

# 测试驱动调试

> 无根因调查，不修复。
> 
> 增强版：因果调试原则 - 确定性回放、动态切片和验证门禁

---

## 🚨 何时激活此技能

| 触发条件 | 优先级 | 备注 |
|---------|----------|-------|
| 任何测试失败 | 高 | 立即开始 |
| CI/CD流水线变红 | 高 | 部署受阻 |
| "在我机器上能跑" | 中 | 环境问题 |
| 检测到不稳定测试 | 中 | 非确定性 |
| 修改后出现回归 | 高 | 最近引入 |
| 生产环境事故 | 关键 | 时间敏感 |

---

## 铁律

```
无根因调查，不修复

如果还没完成阶段1，就不能提出修复方案。
违反这条就是违反调试精神。

另外：永远不要发送未验证的修复
- 覆盖率必须达到阈值
- 变异测试必须通过
- 所有现有测试必须通过
```

---

## 核心原则

### 1. 🟢 确定性优先

在处理其他之前，先使失败可复现：

```bash
# 冻结环境
npm install --frozen-lockfile
node --version
npm --version

# 捕获精确输入
cp -r test/fixtures/ /tmp/debug/
```

### 2. 🔬 科学方法

调试是假设测试，不是猜测：

```
假设 → 测试 → 证据 → 结论

永远不要："我觉得这可能行"
永远要："如果X导致Y，那么Z应该发生"
```

### 3. 📏 最小复现

隔离到最小可能的情况：

```
❌ "整个测试套件失败"
✅ "这个单独测试用这些精确输入失败"
```

### 4. 🛡️ 验证门禁

不带着证明就不发版：

| 门禁 | 阈值 | 工具 |
|------|-----------|------|
| 单元测试 | 100%通过 | jest, pytest |
| 覆盖率 | >80%变更 | coverage report |
| 变异测试 | >90%杀死 | stryker, mutmut |
| 类型检查 | 0错误 | tsc --noEmit |

---

## 阶段1：根因调查

**时间盒：最多15-30分钟**

### 步骤1.1：错误分析

错误信息中的每个字都很重要：

```markdown
## 错误分析

### 完整错误信息
[复制完整 - 不截断]

### 堆栈跟踪读取
- 入口点：流程从哪里开始
- 失败点：哪里崩溃
- 关键帧：[列出重要调用]

### 错误分类
[ ] TypeError - null/undefined访问
[ ] ReferenceError - 变量未找到
[ ] SyntaxError - 解析失败
[ ] AssertionError - 期望失败
[ ] TimeoutError - 异步未解决
[ ] NetworkError - API不可达
[ ] MemoryError - OOM，栈溢出
```

### 步骤1.2：确定性复现

```bash
# 隔离确切的失败用例
npm test -- --grep "精确测试名称" --verbose

# 隔离运行（不并行）
npm test -- --runInBand

# 捕获环境
node --version > env.txt
npm list > deps.txt

# 冻结随机种子
export seed=12345
```

**复现检查清单：**
- [ ] 能可靠触发（>3次）？
- [ ] 确切步骤已记录？
- [ ] CI和本地都相同？
- [ ] 导致失败的最小输入？

### 步骤1.3：Git考古

```bash
# 文件最近变更
git log --oneline -10 -- path/to/file.ts

# 这个提交改了什么？
git show <提交> --stat

# 查找破坏提交（如果是回归）
git bisect start
git bisect bad HEAD
git bisect good <已知良好提交>
git bisect run npm test
```

### 步骤1.4：动态切片（高级）

只识别导致失败的代码：

```
概念：动态切片 = 导致bug的最小代码路径

技术：
1. 从失败点开始
2. 沿栈向后追溯
3. 只保留影响失败的变量
4. 忽略无关代码
```

---

## 阶段2：模式分析

### 步骤2.1：失败模式库

| 模式 | 可能原因 | 快速检查 |
|------|----------|----------|
| `期望X得到Y` | 差一错误，错误值 | 打印实际值 |
| `无法读取undefined的属性` | 缺少空值检查 | 追溯来源 |
| `超时` | 异步未完成 | 记录异步步骤 |
| `Mock未调用` | 错误参数/模块 | 记录实际调用 |
| `元素未找到` | 选择器过时 | 检查DOM快照 |
| `本地能跑CI失败` | 环境差异 | 比较配置 |
| `有时能跑有时不行` | 竞态条件 | 添加延迟 |
| `内存泄漏` | 未释放引用 | 堆快照 |

### 步骤2.2：对比可工作vs失败

| 方面 | 可工作 | 失败 | 差异 |
|------|---------|---------|-------|
| 输入 | ? | ? | ? |
| 状态 | ? | ? | ? |
| 配置 | ? | ? | ? |
| 时序 | ? | ? | ? |

### 步骤2.3：LLM辅助分析

用AI加速模式识别：

```
提示："分析这个堆栈跟踪并建议可能的根因：
[粘贴完整错误]"
```

**验证AI建议：**
- 手动验证
- 小测试用例
- 不要只相信表面

---

## 阶段3：假设测试

### 假设模板

```markdown
### 假设 #N

**陈述：** "错误发生因为[具体原因]"

**证据：**
- [支持事实1]
- [支持事实2]

**测试：** [验证的最小测试]

**如果为真期望：** [具体可观察结果]

**结果：** [确认/否定/不确定]

**新信息：** [学到了什么]
```

### 假设测试日志

| # | 假设 | 测试 | 结果 | 结论 |
|---|------|------|------|------|
| 1 | | | ✓/✗ | |
| 2 | | | ✓/✗ | |
| 3 | | | ✓/✗ | |

### 规则

1. 一次只测试一个假设
2. 最小化改动来测试
3. 记录后再继续
4. 如果否定，更新理解

### 时间盒

```
设置明确时间限制：
- 假设测试：最多15分钟
- 如果没进展：休息一下
- 3次失败后：咨询同事
```

---

## 阶段4：实现

### 步骤4.1：创建复现测试

```javascript
// 首先：写因为bug失败的测试
it('应该正确处理边界情况X', () => {
  const result = process(X);
  expect(result).toBe(expected); // 当前失败
});
```

**为什么先写？** 确保修复bug，不是掩盖

### 步骤4.2：最小修复

```javascript
// 只改必要的
// 不要重构
// 不要加功能
// 只需要修复bug
```

### 步骤4.3：验证门禁

```bash
# 1. 单元测试
npm test -- --grep "相关"

# 2. 覆盖率门禁
npm run test -- --coverage
# 必须覆盖 >80% 变更代码

# 3. 变异测试（推荐）
npx stryker run
# 必须杀死 >90% 变异体

# 4. 完整套件
npm test
```

---

## 📁 目录结构

```
test-driven-debugging/
├── SKILL.md
├── references/
│   └── patterns/
│       └── failure-patterns.md    # 综合模式库
├── examples/
│   └── scenarios/
│       └── debugging-scenarios.md # 真实调试案例
├── templates/
│   ├── hypothesis-template.md     # 假设测试表单
│   └── error-analysis.md         # 错误分析工作表
└── scripts/
    └── bisect-automate.sh        # Git二分查找自动化
```

---

## 📖 参考文件

| 类别 | 位置 | 内容 |
|----------|----------|----------|
| **模式** | `references/patterns/` | 20+失败模式 |
| **场景** | `examples/scenarios/` | 真实调试案例 |
| **模板** | `templates/` | 假设、错误分析 |
| **脚本** | `scripts/` | 自动化助手 |

---

## 三次失败规则

```
三次修复失败后：

停止。这表明：
- 根因假设错误
- 架构问题
- 缺少信息

行动：
1. 回滚所有改动
2. 休息一下（新视角）
3. 咨询其他工程师
4. 考虑现在是否值得修复
```

---

## 🛑 红旗 - 立即停止

| 想法 | 现实 | 行动 |
|------|------|------|
| "让我试试这个修复" | 猜测 | 停止 → 做阶段1 |
| "也许增加超时就行" | 掩盖症状 | 找根因 |
| "可能只是不稳定" | 假设 | 系统调查 |
| "在我机器上能跑" | 环境差异 | 比较配置 |
| "测试通过了发版" | 忽略覆盖率 | 运行变异测试 |

---

## 高级：因果调试

对于复杂bug，应用因果调试原则：

### 1. 确定性回放
```
- 冻结npm版本（--frozen-lockfile）
- 捕获精确输入数据
- 记录随机种子
- 记录时序/环境
```

### 2. 动态切片
```
- 从失败点开始
- 沿栈向后追溯
- 只保留影响的变量
- 忽略无关代码
```

### 3. 反事实推理
```
"如果改变X，失败会消失吗？"
"改变Y有影响吗？"
```

### 4. 属性测试
```javascript
// 修复后：验证无回归
test('处理随机输入', () => {
  for (let i = 0; i < 1000; i++) {
    const input = randomInput();
    expect(validate(input)).toBeDefined();
  }
});
```

---

## 快速参考

```
阶段1：根因
□ 阅读完整错误信息
□ 确定性复现
□ 检查最近变更（git）
□ 收集证据

阶段2：模式
□ 找可工作示例
□ 对比失败vs可工作
□ 匹配模式库

阶段3：假设
□ 形成一个假设
□ 最小化测试
□ 记录结果

阶段4：实现
□ 创建失败测试
□ 最小修复
□ 运行验证门禁：
  □ 所有测试通过
  □ 覆盖率 >80%
  □ 变异 >90%

永远不要：
- 无证据猜测
- 跳过验证门禁
- 不测试就发版
```

---

## 限制

- 无法调试无法复现的case
- 某些bug需要特定环境
- 时间敏感的事故可能需要变通
- 第三方库bug需要上游修复
